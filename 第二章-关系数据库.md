# 第二章·关系数据库
> 1970年，E.F.Codd在美国计算机学会会刊《Communications of the ACM》上发表了题为“A Relational Model of Data for Shared Data Banks”的论文，开创了数据库系统的新纪元。ACM 1983年把这篇论文列为从1958年以来的四分之一世纪中具有里程碑意义的25篇研究论文之一。此后E.F.Codd连续发表了多篇论文，奠定了关系数据库的理论基础
> 2.1 关系数据结构及形式化定义
> 2.2 关系操作
> 2.3 关系的完整性
> 2.4 关系代数
> 2.5 关系演算

[TOC]

## 2.1 关系数据结构及其形式化定义
> 关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成
> 本节主要介绍关系数据结构

### 2.1.1 关系
关系模型的数据结构非常简单，只包含单一的数据结构——**关系**  
在用户看来，关系模型中数据的逻辑结构是一张扁平的二维表
- 1.域（domain）    
域是一组具有相同数据类型的值的集合
- 2.**笛卡尔积**（cartesian product）  
	- 给定一组域D$_{1}$，D$_{2}$，……，D$_{n}$，允许其中某些域是相同的，D$_{1}$，D$_{2}$，……，D$_{n}$的笛卡尔积为：$$D_{1}*D_{2}*……*D_{n}=\{(d_{1},d_{2},……,d_{n}) | d_{i}∈D_{i},i=1,2,……,n\}$$
	- 期中，每一个元素$(d_{1},d_{2},……,d_{n})$叫做一个n元组（n-tuple），简称元组（tuple）
	- 元素中的每一个值$d_{i}$叫做一个分量（component）
	- 一个域允许的不同取值个数称为这个域的基数（cardinal number），设上式基数分别为$m_{i}$，则笛卡尔积的基数$M$为：$$M=\prod_{i=1}^{n}m_{i}$$
	- 笛卡尔积可以表示为一张二维表，表中的每一行对应一个元组，表中的每一列的值来自一个域
- 3.关系（relation）
	- $D_1*D_2*……*D_n$的子集叫做在域$D_1，D_2，……，D_n$上的关系，表示为：$R(D_1，D_2，……，D_n)$
	- 关系中的每个元素是关系中的元组，通常用t表示
	- 当n等于1时，该关系为单元关系/一元关系（unary relation）
	- 当n等于2时，该关系为二元关系（binary relation）
	- 每列的名字称为属性（attribute）
	- 候选码（candidate key）：关系中能唯一标识一个元组的属性组，而其子集不能
	- 若一个关系具有多个候选码，则选定其中一个作为主码（primary key）
	- 候选码的诸属性称为主属性（prime attribute），不包含在任何候选码中的属性称为非主属性（non-prime attribute）或非码属性（non-key attribute）
	- 若这个关系模式的所有属性是这个关系的候选码，称为全码（all-key）
	- 关系可以有三种类型：**基本关系（基本表）、查询表和视图表**
	- **基本关系具有以下六条性质**
		- 列是同质的（homogeneous），每一列中的分量来自同一个域
		- 不同的列可以出自一个域，但具有不同的属性名
		- 列的顺序可以任意交换
		- 行的顺序可以任意交换
		- 任意两个元组的候选码不能取相同的值
		- 分量必须取原子值，即分量是不可分的数据项
	- 关系模型要求关系必须是规范化（normalization）的，最基本的是关系的每一个分量必须是一个不可分的数据项

### 2.1.2 关系模式
- 关系的描述称为关系模式（relation schema），可以形象化的表示为：$$R(U,D,DOM,F)$$
	- R为关系名
	- U为组成该关系的属性名集合
	- D为U中属性所来自的域
	- DOM为属性向域的映像集合
	- F为属性间数据的依赖关系集合*（本章中不涉及）*
- 通常可以简记为：$$R(U)$$或$$R(A_1,A_2,……,A_n)$$,其中$A_i$称为属性名
- **关系模式是静态的，稳定的；关系是动态的、随时间不断变化的**

### 2.1.3 关系数据库
- 关系模型中，实体以及实体间的联系都是用关系来表示的
- 关系数据库的型也称为关系数据库模式，是对关系数据库的描述
- 关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库

### 2.1.4 关系模型的存储结构
- 实体以及实体间的联系都用表来表示，但表是关系数据的逻辑模型
- 关系数据库的物理组织中，有的是一个表对应一个操作系统文件，物理数据组织交给操作系统完成；有的关系数据库管理系统从操作系统那申请空间后自行划分空间并组织存储结构。

## 2.2 关系操作
> 不同的关系数据库可以定义和开发不同的语言开实现对数据的操作

### 2.2.1 基本的关系操作
- 关系模型中常用的关系操作包括
	- 查询（query）操作
	- 插入（insert）、删除（delete）、修改（update）操作
- 关系的查询表达能力很强，查询操作又可以分为
	- **选择（select）**
	- **投影（project）**
	- 连接（join）
	- 除（divide）
	- **并（union）**
	- **差（except）**
	- 交（intersection）
	- **笛卡尔积**
	- etc.
- 操作的对象和结果都是集合→一次一集合（set-at-a-time）方式

### 2.2.2 关系数据语言的分类
- 早期关系操作能力通常用代数方式或逻辑方式表示，分别称为**关系代数（relational algebra）**和**关系演算（relational calculus）**
- 关系演算可以按照谓词变元的基本对象是元组变量还是域变量分为**元组关系演算**和**域关系演算**
- 关系代数、元组关系演算和域关系演算都是抽象的查询语言，实际的查询语言除了提供关系代数或关系演算的功能外还提供很多附加功能
- 还有一种介于关系代数和关系演算之间的**结构化查询语言（Structured Query Language，SQL）**，是集查询、数据定义语言、数据操纵语言和数据控制语言（Data Contorl Language，DCL）于一体的关系数据语言
- 关系数据语言可以分为三类
	- 关系代数语言（如ISBL）
	- 关系演算语言
		- 元组关系演算语言（如ALPHA、QUEL）
		- 域关系演算语言（如QBE）
	- 具有关系代数和关系演算双重特点的语言（如SQL）
- 特别的，SQL是一种高度非过程化的语言

## 2.3 关系的完整性
> 关系模型的完整性规则是对关系的某种约束条件，实际上是现实世界的要求
> 关系模型中有三类完整性约束：**实体完整性（entity integrity）、参照完整性（referential integrity）和用户定义的完整性（user-defined integrity）**
> 实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的**两个不变性**

### 2.3.1 实体完整性
关系数据库中的每个元组应该是可区分的，是唯一的。  
- **实体完整性规则**：若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取空值（null value） *空值：“不知道”或“不存在”或“无意义”的值*  
若为一组属性，则任意一个都不能是空值
- 对于实体完整性规则
	- 实体完整性规则是针对基本关系而言的，一个基本表通常对应现实世界的一个实体集
	- 现实世界中的实体是可以区分的，即它们具有某种唯一性标识，关系模型中以主码作为唯一性标识
	- 主码中的属性不能取空值

### 2.3.2 参照完整性
现实世界中的实体之间往往存在着某种联系，在关系模型中实体以及实体间的联系都是用关系来描述的，这样就自然存在着关系与关系之间的引用
- 设F是基本关系R的一个或一组属性，但不是关系R的码，$K_s$是基本关系S的主码。如果F与$K_s$相对应，则称F是R的外码（foreign key），并称基本关系R为参照关系（referencing relation），基本关系S为被参照关系（referenced relation）或目标关系（target relation）。*关系R与S不一定是不同的关系*
- **参照完整性规则**：若属性或属性组F是基本关系R的外码，它与基本关系S的主码$K_s$相对应，则对于R中每个元组在F上的值必须：
	- 或者取空值（F的每个属性值都为空值）
	- 或者等于S中某个元组的主码值
- R和S可以是同一个关系

### 2.3.3 用户定义完整性
- 用户定义的完整性就是针对某一具体关系数据库的约束条件，他反应某一具体应用所涉及的数据必须满足的语义要求
- 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能

## 2.4 关系代数
> 关系代数是一种抽象的查询语言，**它用对关系的运算来表达查询**
> 关系代数的运算对象是关系，运算结果也是关系
> 关系代数用到的运算符包括两类：集合运算符和专门的关系运算符
> 按运算符的不同可分为**传统的集合运算**和**专门的关系运算**两类

### 2.4.1 传统的集合运算
传统的集合运算是**二目运算**，包括并、差、交、笛卡尔积4种运算
- 1.并（union）
	- 关系R与关系S的并记作：$$R\cup S = \{t|t\in R\lor t\in S \}$$
	- 其结果仍为n目关系，由属于R或属于S的元组组成
- 2.差（except）
	- 关系R与关系S的差记作：$$R-S = \{t|t\in R\land t\notin S \}$$
	- 其结果仍为n目关系，由属于R而不属于S的所有元组组成
- 3.交（intersection）
	- 关系R与关系S的交记作：$$R\cap S = \{t|t\in R\land t\in S \}$$
	- 其结果仍为n目关系，由既属于R又属于S的元组组成
- 4.笛卡尔积（cartesian product）
	- 记作$$R\times S=\{\mathop{t_rt_s}\limits^{\frown}|t_r\in R\land t_s\in S\}$$
	- *此处笛卡尔积严格的讲是广义的笛卡尔积（extended cartesian product），因为此处笛卡尔积的元素是元组*
	- 两个分别为n目和m目的关系R和S的笛卡尔积是一个n+m列的元组的组合，元组的前n列是关系R的一个元组，后m列是关系S的一个元组
	- 若R有k~1~个元组，S有k~2~个元组，则关系R和关系S的笛卡尔积有k~1~*k~2~个元组

### 2.4.2 专门的关系运算
专门的关系运算符包括选择、投影、连接、除运算
- 1.选择（selection）
	- 记作：$\sigma _F(R)=\{t|t\in R \land F(t)='真'\}$
	- 选择又称为限制（restriction）。它是在关系R中满足给定条件的诸元组
	- 选择运算实际上是从关系R中选取使逻辑表达式F为真的元组，是从行的角度进行的运算
- 2.投影（projection）
	- 记作：$\prod _A(R)=\{t[A]|t\in R\}$
	- 关系R上的投影是从R中选择出若干属性列组成新的关系
	- 投影操作是从列的角度进行的运算
- 3.连接（join）
	- 记作：${R\infty S}_{A\theta B}=\{\mathop{t_rt_s}\limits^{\frown}|t_r\in R \land t_s\in S\land t_r[A]\theta t_s[B]\}$  
*注：打不出来连接的符号，此处用'\infty'代替*
	- 连接也称为$\theta$连接，他是从两个关系的笛卡尔积中选取属性间满足一定条件的元组
	- 连接运算中有两种最为重要也是最为常用的连接，等值连接（equijion）和自然链接（natural join）
		- $\theta$为“=”的连接运算为等值连接，他是从R与S的广义笛卡尔积中选取A、B属性值相等的那些元组
		- **自然连接是一种特殊的等值连接**，它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉。即若R和S中具有相同的属性组B，U为R和S的全体属性集合，则自然连接可记作：$R\infty S=\{\mathop{t_rt_s}\limits^{\frown}[U-B]|t_r\in R \land t_s\in S\land t_r[A]\theta t_s[B]\}$
	- 一般的连接操作是从行的角度进行运算，但自然连接还要取消重复列，所以是同时从行和列的角度进行运算
	- 被自然连接舍弃的元组称为**悬浮元组（dangling tuple）**
	- 如果把悬浮元组也保存在结果关系中，而在其他属性组上填空值（NULL），那么这种连接就叫做外连接（outer join），只保留左边关系R中的悬浮元组就叫做左外连接（left outer join），只保留右边关系S中的悬浮元组就叫做右外连接（right outer join）
- 4.除运算（division）
	- 记作：$R\div S=\{t_r[X]|t_r\in R \land \prod _Y(S)\subseteq Y_x\}$
	- 设关系R除以关系S的结果为关系T，则**T包含所有在R但不在S中的属性及其值，且T的元组与S的元组的所有组合都在Ｒ中**
	- 除操作是同时从行和列的角度进行运算
**关系代数中，这些运算经有限次复合后形成的表达式称为关系代数表达式**

## 2.5 Log
- 2021.3.21 第一次编写完成并上传[Github](https://github.com/CharlieQYQ/BUPT-DataBase-MarkDown)