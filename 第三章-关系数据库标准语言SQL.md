# 第三章·关系数据库标准语言SQL
>乔毅
>学号：2019210472
>结构化查询语言（Structured Query Language，SQL）是关系数据库的标准语言，也是一个通用的，功能极强的关系数据库语言
>SQL功能不仅是查询，还包括数据库模式创建、数据库数据的插入与修改、数据库安全性完整性定义与控制等一系列功能

[TOC]

## 3.1 SQL概述
>自SQL成为国际标准语言后，各个数据库厂家纷纷推出各自的SQL软件或与SQL的接口软件。这就使大多数数据库均用SQL作为共同的数据存取语言和标准接口，使不同数据库之间的互操作有了共同的基础
>SQL已经成为数据库领域中的主流语言，意义十分重大

### 3.1.1 SQL的产生与发展
- SQL是在1974年由Boyee和Chamberlin提出的，最初叫Sequel
- 由于SQL简单易学，功能丰富，深受用户及计算机工业界欢迎，因此被数据库厂商采用
- 1986年10月，美国国家标准局的数据库委员会X3H2批准了SQL作为关系数据库语言的美国标准，同年公布了SQL标准文本。1987年，国际标准化组织也通过了这一标准
- **目前，没有一个数据库系统能够支持SQL标准的所有概念和特性**
- 许多软件厂商对SQL基本命令集进行了扩充了修改，可以支持新的功能特性

### 3.1.2 SQL的特点
SQL之所以能够为用户和业界所接受并成为国际标准，是因为它是一个综合的、功能极强同时又简洁易学的语言  
SQL集数据查询（data query）、数据操纵（data manipulation）、数据定义（data defination）和数据控制（data control）功能于一体
- 1.综合统一
	- 数据库系统的主要功能是通过数据库支持的数据语言来实现的
	- SQL集数据定义语言（模式DDL）、数据操纵语言（DML）、数据控制语言的功能于一体，语言风格统一，可以独立完成数据库生命周期中的全部活动
		- 定义和修改、删除关系模式，定义和删除视图，插入数据，建立数据库
		- 对数据库中的数据进行查询和更新
		- 数据库重构和维护
		- 数据库安全性、完整性控制，以及事务控制
		- 嵌入式SQL和动态SQL定义
	- 可以随时地、逐步地修改模式，并不影响数据库的运行，从而使系统具有良好的可扩展性
- 2.高度非过程化
	- 非关系数据模型的数据操纵是“面向过程”的语言
	- SQL进行数据操作只要提出“做什么”，而无须指明“怎么做”，存储路径的选择以及SQL的操作过程由系统自动完成
	- SQL这种操作模式减轻了用户负担，也有利于提高数据独立性
- 3.面向集合的操作方式
	- 非关系数据模型采用的是面向记录的操作方式，操作对象是一条记录
	- SQL采用集合操作方式，不仅操作对象、查找结果可以是元组的组合，而且一次插入、删除、更新操作的对象也可以是元组的集合
- 4.以同一种语法结构提供多种使用方式
	- SQL既是独立的语言，又是嵌入式语言
		- 作为独立的语言，他能够独立地用于联机交互的使用方式，用户可以在终端键盘上直接键入SQL命令对数据库进行操作
		- 作为嵌入式语言，SQL语句能够嵌入到高级语言（如C++，Java）程序中，供程序员设计程序时使用
	- 这两种使用方式下，SQL的语法结构基本一致
- 5.语言简洁、易学易用
	- SQL功能极强，且语言十分简洁，完成核心功能只使用九个动词
	|SQL功能|动词|
	|:----:|:----:|
	|数据查询|SELECT|
	|数据定义|CREATE，DROP，ALTER|
	|数据操纵|INSERT，UPDATE，DELETE|
	|数据控制|GRANT，REVOKE|
	- SQL接近英语口语，易于学习和使用

### 3.1.3 SQL的基本概念
- 支持SQL的关系数据库管理系统同样支持关系数据库三级模式结构
	- 外模式包括若干视图（view）和部分基本表（base table）
	- 数据库模式包括若干基本表
	- 内模式包括若干储存文件（stored file）
- 用户可以用SQL对基本表和视图进行查询或其他操作，基本表和视图一样，都是关系
	- **基本表是本身独立存在的表**，在关系数据库管理系统中**一个关系就对应一个基本表**，一个或多个基本表对应一个储存文件，一个表可以带若干索引，索引也存放在储存文件中
	- **存储文件的逻辑结构组成了关系数据库的内模式**，存储文件的物理结构对最终用户是隐藏的
	- **视图是从一个或几个基本表导出的表**。**它本身并不独立储存在数据库中**，即数据库中**只存放视图的定义**而不存放对应的数据。这些数据仍然存放在导出视图的基本表中，因此视图是一个虚表。视图上可以再定义视图

## 3.2 学生-课程数据库
本部分为后续介绍的示例介绍，详见课本77-78页。此处不再赘述

## 3.3 数据定义
> SQL的数据定义功能包括模式定义、表定义、视图和索引的定义
> SQL标准不提供修改模式定义和修改视图定义的操作，所以只能先删除然后重建
> SQL标准也没有提供索引相关的语句，商用的关系数据库管理系统一般会提供
> **一个关系数据库管理系统的实例（instance）中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象**

|操作对象|创建|删除|修改|
|:----:|:----:|:----:|:----:|
|模式|CREATE SCHEMA|DROP SCHEMA||
|表|CREATE TABLE|DROP TABLE|ALTER TABLE|
|视图|CREATE VIEW|DROP VIEW||
|索引|CREATE INDEX|DROP INDEX|ALTER INDEX|

### 3.3.1 模式的定义与删除
- 1.定义模式
	- SQL中，模式定义语句如下：
	``` sql
	CREATE SCHEMA <模式名> AUTHORIZATION <用户名>
	```
	- 如果没有指定<模式名>，那么模式名隐含为<用户名>
	- 创建模式，调用该命令的用户必须拥有管理员权限，或有数据库管理员授予的`CREATE SCHEMA`的权限
	- 定义模式实际上定义了一个命名空间，在这个空间上可以进一步定义该模式包含的数据库对象，如：
	``` sql
	CREATE SCHEMA <模式名> AUTHORIZATION <用户名>[<表定义字句>|<视图定义字句>|<授权定义字句>]
	```
- 2.删除模式
	- SQL中，删除模式语句如下：
	``` sql
	DROP SCHEMA <模式名> <CASCADE|RESTRICT>
	```
	- CASCADE和RESTRICT二者必选其一
		- CASCADE（级联）表示在删除模式的同时把模式中所有的数据库对象全部删除
		- RESTRICT（限制）表示如果在该模式下已经定义了下属的数据库对象，则拒绝删除语句的执行。只有当该模式下没有任何的下属对象才执行`DROP SCHEMA`语句

### 3.3.2 基本表的定义、删除与修改
- 1.定义基本表
	- 创建了一个模式就建立了一个数据库的命名空间，一个框架。在这个空间中首先要定义的是该模式包含的数据库基本表
	- SQL语言使用`CREATE TABLE`语句定义基本表，其基本格式如下：
	``` sql
	CREATE TABLE <表名>(<列名> <数据类型>[列级完整性约束条件] [,<列名> <数据类型> [列级完整性约束条件]]...[,<表级完整性约束条件>])
	```
	- 建表的同时通常还可以定义该表有关的完整性约束条件，涉及多个属性列的完整性约束条件必须定义在表级上，否则既可以定义在表级也可以定义在列级
	- **参照表和被参照表可以是一个表**
- 2.数据类型
	- 关系模型中一个很重要的概念是域。每一个属性来自一个域，它的取值必须是域中的值
	- SQL中域的概念用数据类型来实现，定义表的各个属性时需要指明其数据类型及长度
	|数据类型|含义|
	|:----:|:----:|
	|CHAR(n),CHARACTER(n)|长度为n的定长字符串|
	|VARCHAR(n),CHARACTERVARYING(N)|最大长度为n的变长字符串|
	|CLOB|字符串大对象|
	|BLOB|二进制大对象|
	|INT,INTEGER|长整数（4字节）|
	|SMALLINT|短整数（2字节）|
	|BIGINT|大整数（8字节）|
	|NUMERIC(p,d)|定点数，由p位数字（不包括符号、小数点）组成，小数点后面有d位数字|
	|DECIMAL(p,d),DEC(p,d)|同NUMERIC|
	|REAL|取决于机器精度的单精度浮点数|
	|DOUBLE PRECISION|取决于机器精度的双精度浮点数|
	|FLOAT(n)|可选精度的浮点数，精度至少为n位数字|
	|BOOLEAN|逻辑布尔量|
	|DATE|日期，包含年、月、日，格式为YYYY-MM-DD|
	|TIME|时间，包含一日的时、分、秒，格式为HH:MM:SS|
	|TIMESTAMP|时间戳类型|
	|INTERVAL|时间间隔类型|
	- 一个属性选用那种数据类型要根据实际情况来决定
		- **取值范围**
		- 要做什么运算
- 3.模式与表
	- 每一个基本表都属于某一个模式，一个模式包含多个基本表
	- 定义基本表时可以用三种方法定义它所属的模式
		- 方法一：在表名中明显的给出模式名
		``` sql
		CREATE TABLE "模式名".<表名>(...)
		```
		- 方法二：在创建模式语句中同时创建表，见3.3.1
		- *方法三：设置所属的模式，这样在创建表时表名中不必给出模式名（不推荐）*
- 4.修改基本表
	- SQL语言用`ALTER TABLE`语句修改基本表，其一般格式为
	``` sql
	ALTER TABLE <表名> 
	[ADD [COLUMN] <新列名> <数据类型> [完整性约束]]
	[ADD <表级完整性约束>]
	[DROP [COLUMN] <列名> [CASCADE|RESTRICT]]
	[DROP CONSTRAINT<完整性约束名> [RESTRICT|CASCADE]]
	[ALTER COLUMN <列名> <数据类型>]
	```
	- <表名>是要修改的基本表。`ADD`子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件。`DROP COLUMN`子句用于删除表中的列，如果指定了CASCADE短语，则自动删除引用了该列的其他对象；如果指定了RESTRICT短语，则如果该列被其他对象引用，RDBMS将拒绝删除该列。`DROP CONSTRAINT`子句用于删除指定的完整性约束条件。`ALTER COLUMN`子句用于修改原有的列定义，包括修改列名和数据类型
- 5.删除基本表
	- 当某个表不再需要时，可以用`DROP TABLE`语句删除它，其一般格式为：
	``` sql
	DROP TABLE <表名> [RESTRICT|CASCADE] 
	```
	- 若选择RESTRICT（默认），则该表的删除是有限制条件的，欲删除的基本表不能被其他的表的约束所引用（如CHECK，FOREIGN KEY等约束），不能有视图，不能有触发器（trigger），不能有存储过程或函数等。如果有上述存在，则此表不能被删除
	- 若选择CASCADE，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象也会一起删除

### 3.3.3 索引的建立与删除
- 0.当表的数据量比较大时，查询操作会比较耗时。建立索引是加快查询速度的有效手段
	- 索引能够快速的定位到查询的内容
	- 索引虽然能够加快数据库查询，但需要占用一定的存储空间，当基本表更新时，索引要进行相应的维护，这些都增加了数据库的负担，因此要根据实际情况有选择的创建索引
	- 目前SQL标准中没有索引，但商用关系数据库管理系统一般都支持索引机制
	- **用户不必也不能显式地选择索引**，索引是属于内模式的范畴
- 1.建立索引
	- 在SQL语言中，建立索引使用`CREATE INDEX`语句，其一般格式为：
	``` sql
	CREATE [UNIQUE] [CLUSTER] INDEX <索引名> ON <表名>(<列名> [<次序>] [,<列名> [<次序>]...])
	```
	- 其中，<表名>是要建立索引的基本表的名字，索引可以建立在该表的一列或多列上，可以用<次序>指定索引值的排列次序，可选ASC（升序）或DESC（降序），默认为ASC
	- UNIQUE表名此索引的每一个索引值只对应唯一的数据记录
	- CLUSTER表示要建立的索引是聚簇索引
- 2.修改索引
	- 对于已经建立的索引，如果需要对其重新命名，可以使用`ALTER INDEX`语句，其一般格式为：
	``` sql
	ALTER INDEX <旧索引名> RENAME TO <新索引名>
	```
- 3.删除索引
	- 索引一经建立就由系统使用和维护，不需要用户干预
	- 如果系统维护索引需要花费很多时间（频繁增删改数据），就可以删除不必要的索引
	- 在SQL中，删除索引使用`DROP INDEX`语句，其一般格式为：
	``` sql
	DROP INDEX <索引名>
	```
	- 删除索引时，系统会同时从数据字典中删去有关该索引的描述

### 3.3.4 数据字典
- 数据字典是关系数据库管理系统内部发热一组系统表，他定义了：
	- 数据库中所有的定义信息
		- 关系模式定义
		- 视图定义
		- 索引定义
		- 完整性约束定义
	- 各类用户对数据库的操作权限、统计信息等
- 关系数据库在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息

## 3.4 数据查询
> 数据查询是数据库的核心操作，SQL提供了`SELECT`语句进行数据查询，其一般格式为：
``` sql
SELECT [ALL|DISTINCT] <目标列表达式> [,<目标列表达式>] ...
FROM <表名或视图名> [,<表名或视图名>]|(<SELECT语句>) [AS] <别名>
[WHERE <条件表达式>]
[GROUP BY <列名1> [HAVING <条件表达式>]]
[ORDER BY <列名2> [ASC|DESC]]
```
> 整个`SELECT`语句的含义是，根据`WHERE`子句的条件表达式从`FROM`子句指定的基本表、视图或派生表中找出满足条件的元组，再按`SELECT`子句中的目标列表达式选出元组中的属性值形成结果表
> `GROUP BY`子句将结果按<列名1>的值进行分组，该属性列值相等的元组位于一个组
> `ORDER BY`子句将结果按照<列名2>的值升序或降序排序

### 3.4.1 单表查询
单表查询是指仅涉及一个表的查询
- 1.选择表中的若干列
选择表中的全部或部分列即关系代数的投影运算  
	- （1）查询指定列：通过在`SELECT`子句的<目标列表达式>中指定要查询的属性列，其中的先后顺序可以和表中的顺序不一致
	- （2）查询全部列：
		- 在`SELECT`关键字后列出所有的列名
		- 如果显示顺序与基表相同，可以将<目标列表达式>指定为"*"
	- （3）查询经过计算的值：`SELCET`子句的<目标列表达式>不仅可以是属性列，也可以是表达式、字符串常量、函数等  
用户可以通过指定别名来改变查询结果的列标题
- 2.选择表中的若干元组
	- （1）消除取值重复的行：可以用DISTINCT消除原本不相同的元组产生的相同投影
	- （2）查询满足条件的元组：可以通过WHERE子句实现，详见下表
	|查询条件|谓词|
	|:----:|:----:|
	|比较|=，＞，＜，＞=，＜=，!=，＜＞，!＞，!＜；NOT+上述比较运算符|
	|确定范围|[NOT] BETWEEN <下限> AND <上限>|
	|确定集合|IN，NOT IN|
	|字符匹配|[NOT] LIKE '<匹配串>' [ESCAPE '<换码字符>']|
	|空值|IS NULL，IS NOT NULL|
	|多重条件（逻辑运算）|AND，OR，NOT|
	字符匹配中通配符：“%”代表任意长度的字符串，“_”代表任意单个字符（ASCⅡ汉字需要两个“_”，GBK汉字只需要一个“_”）
- 3.`ORDER BY`子句
	- 用户可以用`ORDER BY`子句对查询结果按照一个或多个属性列的升序（ASC）或降序（DESC）排序，默认为ASC
	- 对于空值，排序时显示的次序由具体系统实现来决定
- 4.聚集函数
	- 为进一步方便用户，SQL提供了许多聚集函数，主要有：
	|聚集函数|功能|
	|:----:|:----:|
	|COUNT(*)|统计元组个数|
	|COUNT([DISTINCT\|ALL] <列名>)|统计一列中值的个数|
	|SUM([DISTINCT\|ALL] <列名>)|计算一列值（数值型）的总和|
	|AVG([DISTINCT\|ALL] <列名>)|计算一列值（数值型）的平均值|
	|MAX([DISTINCT\|ALL] <列名>)|求一列值中的最大值|
	|MIN([DISTINCT\|ALL] <列名>)|求一列值中的最小值|
	- 如果指定DISTINCT短语，则在计算是要取消指定列中的重复值；如果不指定DISTINCT或者指定ALL（默认），则不取消重复值
	- **当聚集函数遇到空值时，除`COUNT(*)`外，都跳过空值而只处理非空值**
	- **聚集函数只能用于`SELECT`子句和`GROUP BY`中的`HAVING`子句**
- 5.`GROUP BY`子句
	- `GROUP BY`子句将查询结果按某一列或多列的值分组，值相等的为一组
	- **分组后聚集函数将作用于每一个分组，即每一个组有一个函数值**
	- 使用`HAVING`短语指定筛选条件
	**WHERE子句作用于基本表或视图，HAVING短语作用于组**

### 3.4.2 连接查询
之前的查询都是针对一个表进行的。若一个查询同时涉及两个以上的表，则称之为连接查询。  
连接查询是关系数据库中最主要的查询，包括等值连接查询、自然连接查询、非等值连接查询、自身连接查询、外连接查询和复合条件连接查询等
- 1.等值与非等值连接查询
	- 连接查询的`WHERE`子句中用来连接两个表的条件称为连接条件或连接谓词，其一般格式为：`[<表名1>.]<列名1> <比较运算符> [<表名2>.]<列名2>` 其中比较运算符主要有=，＞，＜，＞=，＜=、!=（＜＞）等
	- 连接谓词还可以使用：`[<表名1>.]<列名1> BETWEEN [<表名2>.]<列名2> AND [<表名2>.]<列名3>`
	- **当连接运算符为=时，称为等值连接**，其他运算符称为非等值连接
	- 连接谓词中的列名称为连接字段。**连接条件中的各连接字段类型必须是可比的**，但名字不必相同
	- 若在**等值连接**中**把目标列中重复的属性列去掉则为自然链接**
	- 一条SQL语句可以同时完成选择和连接查询，此时`WHERE`子句是由连接谓词和选择谓词组成的复合条件
- 2.自身链接
	- 连接操作不仅可以在两个表之间完成，也**可以是一个表与其自己进行连接，称为表的自身链接**
	- 要为这一表取别名，如FIRST和SECOND，`<表名> <别名1>，<表名> <别名2>`
- 3.外连接
	- 若想在选择操作中将被舍弃的元组（悬浮元组）也保存在关系中，就要使用外连接
	- 此时在缺省的值上填NULL
	- 左外连接列出左边关系中所有的元组，右外连接列出右边关系中所有的元组
- 4.多表连接
	- 连接操作除了可以是两表连接、一个表与其自身链接外，还可以是两个以上的表进行连接，称为**多表连接**
	- 多表连接的实质是先进行两表连接，将结果再与下一个表进行连接

### 3.4.3 嵌套查询
- ***以层层嵌套的方式来构造程序正是SQL中“结构化”的含义所在***
- 在SQL语言中，**一个`SELECT-FROM-WHERE`语句称为一个查询块**
- 将一个查询块嵌套在另一个查询块的`WHERE`子句或`HAVING`短语的条件中的查询称为**嵌套查询**（nested query）
- 上层的查询块称为**外层查询**或**父查询**，下层查询块称为**内层查询**或**子查询**
	- 1.带有IN谓词的子查询
		- IN表示父查询从子查询选择的元组（元组集合）中再进行选择
			- 子查询的查询条件不依赖于父查询，称为**不相关子查询**
				- 先进行子查询，之后将子查询的结果返回给父查询
				- 速度快，不用反复求值
			- 子查询的查询条件依赖于父查询，称为**相关子查询**（coorelated subquery），整个查询语句称为**相关嵌套查询**
				- 先进行父查询，将父查询的一个结果（元组）调入子查询进行运算，将结果合并后进行下一次父查询
				- 速度慢，需要反复进行父查询求值
		- 实现同一个查询请求可以有多种方法，不同方法的执行效率可能会有差别。数据库编程人员应该掌握数据库性能调优技术
	- 2.带有比较运算符的子查询
		- 带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接
		- 当能确切知道**内层查询返回的是**单个值**时，可以用＞、＜、=、＞=、＜=、!=或＜＞等比较运算符
		- 如果查询结果是一个值，那么=可以代替IN
	- 3.带有ANY（SOME）或ALL谓语的子查询
		- 子查询返回单值时可以用比较运算符，但返回多值时要用ANY（有的系统用SOME）或ALL谓语修饰符
		- 使用ANY或ALL谓词时**必须同时使用比较运算符**
		|语法|含义|
		|:----:|:----:|
		|＞ANY|大于子查询结果中的某个值|
		|＞ALL|大于子查询结果中的所有值|
		|＜ANY|小玉子查询结果中的某个值|
		|＜ALL|小于子查询结果中的所有值|
		|＞=ANY|大于等于子查询结果中的某个值|
		|＞=ALL|大于等于子查询结果中的所有值|
		|＜=ANY|小于等于子查询结果中的某个值|
		|＜=ALL|小于等于子查询结果中的所有值|
		|=ANY|等于子查询结果中的某个值|
		|=ALL|等于子查询结果中的所有值*（通常没有实际意义）*|
		|!=（或＜＞）ANY|不等于查询结果中的某个值|
		|!=（或＜＞）ALL|不等于查询结果中的所有值|
		- 一些谓词和可以用聚集函数代替
	- 4.带有EXISTS谓词的子查询
		
		- EXISTS代表存在量词$\exist$
		- 带有EXISTS谓语的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”
			- EXISTS：若子查询结果非空，则外层的WHERE子句返回真值，否则返回假值
			- NOT EXISTS：若子查询结果为空，则外层的WHERE子句返回真值，否则返回假值
		- 一些带EXISTS和NOT EXISTS谓语的子查询不能被其他形式的子查询等价替换，但所有带IN谓词、比较运算符、ANY和ALL谓语的子查询都能带EXISTS谓语的子查询等价替换

### 3.4.4 集合查询
- SELECT语句的查询结果是元组的集合，所以多个SELECT语句的结果可进行集合操作
- 操作主要包括**并操作UNION、交操作INTERSECT和差操作EXCEPT
	- UNION
		- 使用UNION操作将多个查询结果合并起来时，系统会自动去掉重复元组
		- 如果要保留重复元组则用UNION ALL操作符
		- 可以用OR连接符代替
		``` sql
		{SELECT语句块}
		UNION
		{SELECT语句块}
		```
	- INTERSECT
		- 使用INTERSECT获得多个查询结果的交集
		- 可以用AND连接符代替
		``` sql
		{SELECT语句块}
		INTERSECT
		{SELECT语句块}
		```
	- EXCEPT
		- 使用EXCEPT获得多个查询结果的差集
		- 可以用AND连接符代替
		``` sql
		{SELECT语句块}
		EXCEPT
		{SELECT语句块}
		```

### 3.4.5 基于派生表的查询
- 子查询不仅可以出现在`WHERE`子句中，还可以出现在FROM子句中，这时子查询生成的临时**派生表**（derived table）成为主查询的查询对象
``` sql
SELECT <属性名1>[,<属性名2>,…]
FROM <表名1>,(SELECT <属性名3>[,<属性名4>…]
			FROM <表名2>
			[GROUP BY])
	AS <派生表名>(<属性名3>[,<属性名4>,…])
WHERE "表达式"
```
- 通过`FROM`子句生成派生表时，AS关键字可以省略，但必须为派生关系指定一个别名

### ***3.4.6 SELECT语句的一般格式***
- `SELECT`语句是SQL的核心语句，**`SELECT`语句的一般格式**：
``` sql
SELECT [ALL|DISTINCT] <目标列表达式> [别名] [,<目标列表达式> [别名]] …
FROM <表名或视图名> [别名] [,<表名或视图名> [别名]] … |(<SELECT 语句>) [AS] <别名>
[WHERE <条件表达式>]
[GROUP BY <列名1> [HAVING <条件表达式>]]
[ORDER BY <列名2> [ASC|DESC]];
```

- 1.目标列表达式的可选格式
	- \*
	- <表名>.\*
	- COUNT([DISTINCT|ALL] *)
	- [<表名>.] <属性列表达式> [,[<表名>.] <属性列表达式>] …
- 2.聚集函数的一般形式：COUNT/SUM/AVG/MAX/MIN([DISTINCT|ALL] <列名>)
- 3.WHERE子句的条件表达式的可选格式
	- <属性列名>$\theta$ <属性列名>/<常量>/[ANY|ALL] (SELECT 语句)
	- <属性列名> [NOT] BETWEEN <属性列名>/<常量>/(SELECT 语句) AND <属性列名>/<常量>/(SELECT 语句)
	- <属性列名> [NOT] IN (<值1>[,<值2>]…)/(SELECT 语句)
	- <属性列名> [NOT] LIKE <匹配串>
	- <属性列名> IS [NOT] NULL
	- [NOT] EXISTS (SELECT 语句)
	- <条件表达式> AND/OR <条件表达式> [AND/OR <条件表达式>…]

## 3.5 数据更新
> 数据更新操作有三种：向表中添加若干行数据、修改表中的数据和删除表中的若干行数据
> SQL中有三类语句对应这三种操作

### 3.5.1 插入数据
SQL的数据插入语句`INSERT`通常有两种形式，一种是插入一个元组，另一种是插入子查询的结果。后者可以一次插入多个结果
- 1.插入元组
	- 插入元组的`INSERT`语句的格式为：
	``` sql
	INSERT
	INTO <表名>[(<属性列1>[,<属性列2>]…)]
	VALUES(<常量1>[,<常量2>]…)
	```
	特别的：字符串常数要用单引号''括起来
	- `INTO`子句中没有出现的属性列，新元组在这些列上将取空值NULL。但是在表定义时说明了NOT NULL的属性列不能去空值
	- 如果`INTO`字句中没有指明任何属性列名，则新插入的元组必须在每个属性列上均有值
- 2.插入子查询的结果
	- 子查询也可以嵌套在`INSERT`语句中用以生成要插入的批量数据
	- 插入子查询的`INSERT`语句格式为：
	``` sql
	INSERT
	INTO <表名> [(<属性列1>[,<属性列2>…])]
	子查询
	```

### 3.5.2 修改数据
- 修改操作又称为更新操作，其语句的一般格式为
``` sql
UPDATE <表名>
SET <列名>=<表达式> [,<列名>=<表达式>] …
[WHERE <条件>]
```
- 其功能是修改指定表中满足`WHERE`子句条件的元组，如果省略`WHERE`子句，则表示要修改表中的所有元组
- `SET`子句给出<表达式>的值，用于取代相应的属性列值
	- 1.修改某一个元组的值
	- 2.修改多个元组的值
	- 3.带子查询的修改语句：子查询嵌套在`UPDATE`语句中

### 3.5.3 删除数据
- 删除语句的一般格式为：
``` sql
DELETE
FROM <表名>
[WHERE <条件>]
```
- `DELETE`语句的功能是从指定表中删除满足`WHERE`子句条件中的所有元组
- 如果省略`WHERE`子句则表示删除表中全部元组，**但表的定义仍在字典中**，即**`DELETE`语句删除的是表中的数据，而不是关于表的定义**
	- 1.删除某一个元组的值
	- 2.删除多个元组的值
	- 3.带子查询的删除语句：子查询同样可以嵌套在`DELETE`语句中，用以构造执行删除的条件

## 3.6 空值的处理
*老师讲的时候把这块摸过去了（没讲） 要是讲了再回来写*

## 3.7 视图
> 视图是从一个或几个基本表（或视图）导出的表
> 他是一个虚表，只储存视图的定义而不储存视图应有的数据
> 本节专门讨论视图的定义、操作及作用

### 3.7.1 定义视图
- 1.建立视图
	- SQL语言用`CREATE VIEW`命令建立视图，其一般格式为:
	``` sql
	CREATE VIEW <视图名> [(<列名>[,<列名>]…)]
	AS <子查询>
	[WITH CHECK OPTION]
	```
	只是将定义存入数据字典，并不执行子查询
	- 其中，子查询可以是任意的`SELECT`语句
		- 书上：是否可以含有`ORDER BY`子句和DISTINCT短语取决于具体系统的实现
		- PPT：不可以用`ORDER BY`子句
	- WITH CHECK OPTION表示对视图进行UPDATE、INSERT和DELETE操作时要保证更新、插入或删除的行满足视图定义中的谓语条件（即子查询中的条件表达式）
	- 组成视图的属性列名
		- 要么全部省略：由子查询中目标列的字段组成
		- 要么全部指定
			- 某个目标列不是单纯的属性名，而是聚集函数或列表达式
			- 多表连接时选出了几个同名列作为视图的字段
			- 需要在视图中为某个列启用新的更合适的名字
	- 几类视图
		- 若一个视图是从单个基本表中导出的，并且只是去掉了基本表的某些行和某些列，但是保留了主码，则称这类视图为**行列子集视图**
		- 若定义视图时使用了原本不存在在原表中的属性列（虚拟列），则称这种带虚拟列的视图为**带表达式的视图**
		- 若视图中带有聚集函数和GROUP BY`子句的查询来定义视图，则称这种视图为**分组视图**
	- 视图也可以建立在多个基本表、视图、基本表和视图的组合上
	- 如果修改基本表之后会破坏与视图的映像关系，则最好在修改基本表后删除视图并重新定义
- 2.删除视图
	- 删除语句的格式为：
	``` sql
	DROP VIEW <视图名> [CASCADE]
	```
	- 视图删除后视图的定义将从数据字典中删除，CASCADE语句可以将定义在视图上的其他视图一并删除
	- 只删除基本表并不能一并删除定义在其上的视图定义，需要显式地DROP掉视图

### 3.7.2 查询视图
- 视图在定义后，就可以像基本表一样进行查询操作
- 对视图查询的操作：这一转换过程称为**视图消解**（view resolution）
	- 从数据字典中取出视图的定义
	- 把定义中的子查询和用户的查询结合，转化为等价的对基本表的查询
	- 执行修正了之后的查询
- 多数的关系数据库系统对行列子集视图的查询均能进行正确转换，但对非行列子集视图的查询就不一定能转换了，此时需要直接对基本表进行查询
- 视图和基本表
	- 视图一旦定义，其定义将永久保存在数据字典中，之后所有的查询都可以直接引用该视图
	- 派生表只在语句执行时临时定义，语句执行后该定义即被删除

### 3.7.3 更新视图
- 更新视图是指通过视图来插入（INSERT）、删除（DELETE）和修改（UPDATE）数据。
- 由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换为**对基本表的更新**
- 为了不对不属于视图的数据进行操作，可在定义视图时加上`WITH CHECK OPTION`子句
- 并不是所有的视图都是可以更新的
	- 一般行列子集视图是可更新的
	- 使用聚集函数的视图一般不可更新（如`AVG()`）
	- 不允许更新的视图上定义的视图也不允许更新
- **不可更新的视图和不允许更新的视图是两个不同的概念**
	- 不可更新指理论上证明不能更新
	- 不允许更新指系统不支持对其更新，但本身可能是可以更新的视图

### 3.7.4 视图的作用
- 视图能够简化用户的操作，集中于关心的数据上
- 视图使用户能以多种角度看待同一数据
- 视图对重构数据库提供了一定程度的逻辑独立性
- 视图能对机密数据提供安全保护
- 适当利用视图可以更清晰的表达查询


## 3.8 Log
- 2021.5.29编写完成并上传[Github](https://github.com/CharlieQYQ/BUPT-DataBase-MarkDown)
