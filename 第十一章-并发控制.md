# 第十一章·并发控制
> 乔毅
> 2019210472

数据库是一个共享资源，可以供多个用户使用  
为了充分利用系统资源，发挥数据库共享资源的特点，应该允许多个事务并行的执行  

- 在单处理机系统中，事务的并行执行实际上是这些并行事务的并行操作轮流交叉运行，称为交叉并发方式（interleaved concurrency）  
- 在多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行，称为**同时并发方式**（simultaneous concurrency）
- 当多个用户并发的存取数据库中统一数据时，若对并发操作不加限制，就会造成存取和存储不正确的数据，破坏事务的一致性和数据库的一致性

## 11.1 并发控制概述
**事务是并发控制的基本单位**  
为了保证事务的隔离性和一致性，数据库管理系统需要对并发操作进行正确的调度  
并发操作带来的数据不一致性包括丢失修改、不可重复读和读“脏”数据
- 1.丢失修改（lost update）
	- 两个事物T1和T2读入同一数据并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改被丢失
- 2.不可重复读（non-repeatable read）
	- 不可重复读是指事务T1读取数据后，T2执行更新操作，使得T1无法再现前一次读取结果
	- 包括
		- 事务T1读取数据后，事务T2对其进行修改
		- 事务T1读取数据后，事务T2删除了部分数据
		- 事务T1读取数据后，事务T2插入了一些记录
		- [后两种有时也称为幻影（phantom row）现象]
- 3.读“脏”数据（dirty read）
	- 读“脏”数据指事务T1修改某一数据并写回磁盘，事务T2读取该数据后，事务T1的操作被撤销，使得T2读取的数据与数据库中的数据不一致，T2读取的数据就是“脏”数据，即不正确的数据
	并发控制机制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性  
	并发控制的主要技术有封锁（locking）、时间戳（timestamp）、乐观控制法（optimistic scheduler）和多版本并发控制（multi-version concurrency control，MVCC）等  

## 11.2 封锁
**封锁是实现并发控制的一个非常重要的技术**  
封锁就是事务T在对某个数据对象操作之前，先向系统发出请求，对其加锁  
在事务T释放他的锁之前，其他事务不能更新此数据对象  
基本的封锁类型有两种
- 排它锁（exclusive locks），简称X锁
	- 又称**写锁**
	- 若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务不能再对A增加任何类型的锁，直到T释放A上的锁为止
- 共享锁（share locks），简称S锁
	- 又称**读锁**
	- 若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁为止
	相容矩阵（compatibility matrix）  
|T|X|S|-|
|:--:|:--:|:--:|:--:|
|X|N|N|Y|
|S|N|Y|Y|
|-|Y|Y|Y|

## 11.3 活锁和死锁
和操作系统一样，封锁方法可能引起活锁和死锁等问题  

### 11.4.1 活锁
若事务T1封锁了数据R，事务T2请求封锁R，于是T2等待；此时T3也请求R，当T1释放了R上的封锁后首先允许T3的请求，T2保持等待；然后T4又申请R………。T2可能永远等待，这就是活锁的情景  
避免活锁的方法是采用**先来先服务**的策略，当多个事务请求封锁同一数据对象，封锁子系统按请求封锁的先后次序对事务进行排队  

### 11.4.2 死锁
如果事务T1封锁了数据R1，T2封锁了R2，然后T1请求封锁R2，于是T1等待；T2又请求封锁R1，于是T2等待。这样就出现了T1等待T2，T2又等待T1的情况，这两个事务永远不会结束，形成死锁  
- 1.死锁的预防
	- 数据库中，死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已被其他事务封锁的数据对象加锁，从而出现死等待
	- 预防死锁通常有
		- （1）一次封锁法
			- 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行
			- 降低了系统并发度
		- （2）顺序封锁法
			- 顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务按照这个顺序实施封锁
			- 维护有极多数据对象的封锁顺序非常困难，成本很高
			可见预防死锁的方法不太适合数据库的特点，因此数据库管理系统一般采用诊断并解除死锁的方法  
- 2.死锁的诊断与解除
	数据库中诊断死锁的方法与操作系统类似，一般用超时法或事务等待图法  
	- （1）超时法
		- 如果一个事务的等待时间超过了规定的时限，就认为发生了死锁
		- 有可能误判死锁
		- 若时限设置太长，死锁发生后不能及时发现
	- （2）等待图法
		- 事务等待图动态的反映了所有事务的等待关系
		- 如果发现图中存在回路，则表明系统中出现了死锁
	- 通常选用选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，使得其他事务可以继续运行下去

## 11.5 并发调度的可串行性
串行调度是正确的并发事务的调度  
执行结果等价于串行调度的调度也是正确的，这样的调度叫做可串行化调度  

### 11.5.1 可串行化调度
定义：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行的执行这些事务时的结果相同，称这种调度策略为**可串行化**（serializable）调度  
**可串行性**（serializability）是并发事务正确调度的准则  
一个给定的并发调度，当且仅当它是可串行化的，才认为是**正确调度**  

### 11.5.2 冲突可串行化调度
冲突操作是指不同的事务对同一个数据的读写操作和写写操作  
不同事务的冲突操作和同一事务的两个操作是不能交换（swap）的  
一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc'，如果Sc'是串行的，称调度Sc为**冲突可串行化**的调度  
若一个调度是冲突可串行化，则一定是可串行化的调度  
**冲突可串行化调度是可串行化调度的充分条件，不是必要条件**  

## 11.6 两段锁协议
目前数据库管理系统普遍采用**两段锁**（TwoPhase Locking），简称2PL协议的方法实现并发调度的可串行性，从而保证调度的正确性  
所谓两段锁协议是指所有事物必须分两个阶段对数据项加锁和解锁
- 在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁
- 在释放一个封锁之后，事务不再申请和获得任何其他封锁
在两段锁协议下，事务分为两个阶段
- 第一阶段是获得封锁，也称为扩展阶段
- 第二阶段是释放封锁，也成为收缩阶段

## 11.7 封锁的粒度
封锁对象的大小称为**封锁粒度**（granularity）  
-封锁对象可以是这样一些逻辑单元
	- 属性值
	- 属性值的集合
	- 元组
	- 关系
	- 索引项
	- 整个索引
	- ……
	- 整个数据库
- 也可以是这样一些物理单元
	- 页（数据页或索引页）
	- 物理记录
	- ……
	**封锁粒度与系统的并发度和并发控制的开销密切相关**  
- 封锁的粒度越大，数据库所能封锁的数据单元就越小，并发度就越小，系统开销也小
- 封锁的粒度越小，并发度较高，但系统开销也越大
在一个系统中同时支持多种封锁粒度供不同的事务选择是比较理想的，这种封锁方法称为**多粒度封锁**（multiple granularity locking）

### 11.7.1 多粒度封锁
首先定义**多粒度树**，多粒度树的根结点是整个数据库，表示最大的数据粒度；叶结点表示最小的数据粒度  
**多粒度封锁协议**允许多粒度树中的每个结点被独立地加锁  
对一个结点加锁意味着这个结点的所有后裔节点也被加以同样形式的锁  
- **显式封锁**是应事务的要求直接加到数据对象的锁
- **隐式封锁**是该数据对象没有被独立加锁，是由于其上级结点加锁而使得该数据对象加上了锁
显式封锁和隐式封锁的效果是一样的，因此系统检查封锁冲突时不仅要检查显式封锁还要检查隐式封锁  

### 11.7.2 意向锁
**意向锁**的含义是如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁；对任一节点加锁时，必须先对它的上层结点加意向锁  
三种意向锁
- 1.意向共享锁（Intent Share Lock，IS锁）
	- 如果一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁
- 2.意向排它锁（Exclusive Lock，IX锁）
	- 如果一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁
- 3.共享意向排他锁（Share Intent Exclusive Lock，SIX锁）
	- 如果一个数据对象加SIX锁，表示它加S锁，再加IX锁，即SIX=S+IX
	锁的强度：它对其他锁的排斥程度，以强锁代替弱锁是安全的  
	X＞SIX＞S/IX＞IS  

数据锁的相容矩阵
|T|S|X|IS|IX|SIX|-|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|S|Y|N|Y|N|N|Y|
|X|N|N|N|N|N|Y|
|IS|Y|N|Y|Y|Y|Y|
|IX|N|N|Y|Y|N|Y|
|SIX|N|N|Y|N|N|Y|
|-|Y|Y|Y|Y|Y|Y|

## 11.8 Log
- 2021.5.23 编写完成
- 2021.5.29 上传至[Github](https://github.com/CharlieQYQ/BUPT-DataBase-MarkDown) 